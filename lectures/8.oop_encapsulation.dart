// ignore_for_file: omit_local_variable_types, prefer_final_locals, unused_local_variable, cascade_invocations, prefer_initializing_formals, unnecessary_this, sort_constructors_first, unused_import

import 'dart:collection';
import 'dart:io';
import 'dart:math';

void introduction() {
  //? Парадигмы
  //* Парадигма разработки – это набор правил и критериев, соблюдаемых разработчиками,
  //* чтобы выдержать конкретную стилистику и модель написания кода.

  //* Единая парадигма помогает избегать ошибок, упрощает работу в команде и ускоряет разработку.
  //* Ориентируясь на одну парадигму, можно корректно структурировать код приложения,
  //* зная четкие правила, выбранные командой, которая работает над конкретным проектом.

  //* Существуют различные типы парадигм, например процедурный, ориентированный на работу с функциями,
  //* или логический, подразумевающий решение базовых логических задач в духе «если А = true, то и B = true».
  //* Но есть и более интересный подход к решению задач разработки, и это ООП-парадигма.

  //? ООП
  //* Объектно-ориентированное программирование, ООП – это одна из парадигм разработки, подразумевающая организацию
  //* программного кода, ориентируясь на данные и объекты, а не на функции и логические структуры.

  //* Обычно объекты в подобном коде представляют собой полноценные блоки с данными, которые имеют
  //* определенный набор характеристик и возможностей. Объект может олицетворять ЧТО УГОДНО –
  //* от человека с именем, фамилией, номером телефона, паролем и другой информацией до мелкой утилиты
  //* с минимумом характеристик из реального мира, но увеличенным набором функций.
  //* Объекты могут взаимодействовать друг с другом, пользователем и любыми другими компонентами программы.

  //* ООП заставляет разработчиков фокусироваться на объектах, которыми нужно манипулировать,
  //* а не на той логике, что позволяет изменять данные и как-то с ними взаимодействовать.
  //* Такой подход хорошо работает в случае с комплексными программными решениями,
  //* требующими постоянной поддержки со стороны большого числа программистов.

  //? Почему это круто?
  //* Модульность
  //* Реюзабельность
  //* Расширяемость
  //* Безопастность
  //* Гибкость
  //* И многое другое...

  //? Почему без этого нельзя существовать?
  //* ООП - самая популярная парадигма программирования, она занимает ~55% рынка (25% процедурное и 10% функциональное)
  //* Все причины выводятся из преимуществ

  //? Где это применяется?
  //* Везде...
  //* 1. Порождение
  //* 2. Структура
  //* 3. Поведение

  //! ? Как понять когда использовать?
  //* Необходимо понимать, что ООП - это не панацея, а всего лишь инструмент, который помогает решать задачи
  //* Важно понимать, что ООП не всегда является лучшим решением, и в некоторых случаях лучше использовать другие парадигмы
  //*
  //* Необходимо преобразовать своё видение с процедурного на объектно-ориентированное
  //!!! Нужно научиться выделять "Сущности" и их определенную ответственность!!

  //? Части ООП
  //* Программный код, написанный с учетом принципов ООП, четко структурируется на 4 основных элементах
  //* (иногда выделяют и больше, включая в список элементов модули и другие структуры,
  //* связанные с объектно-ориентированной парадигмой)
  //* 1. Объекты
  //* 2. Методы
  //* 3. Аттрибуты (поля)
  //* 4. Классы

  //? Ключевые принципы ООП
  //* 1. Инкапсуляция
  //* 2. Наследование
  //* 3. Абстракция
  //* 4. Полиморфизм
}

void terms() {
  //? В ООП вводятся следующие термины:
  //* 1. Поле или атрибут – это переменная, объявленная внутри класса.
  //* 2. Метод - это функция, объявленная внутри класса.
  //* 3. Класс – это шаблон, по которому создаются объекты.
  //* 4. Объект – это экземпляр класса.
}

void encapsulation() {
  //? Инкапсуляция
  //!!! Инкапсуляция – это объединение полей и функций в одном классе, с ВОЗМОЖНОСТЬЮ скрыть детали реализации.

  //* Инкапсуляция позволяет создавать объекты, которые могут быть использованы в других частях программы,
  //* не зная, как именно они работают внутри. Это позволяет упростить код, сделать его более понятным и
  //* уменьшить вероятность ошибок при работе с объектами.

  //? Логичные выводы
  //* 2 объекта одного класса могут иметь разные значения полей
}

void createClass() {
  //? Создание класса
  //* Сперва мы должны создать чертеж для объектов – класс. Класс описывает, какие данные и функции будут у объектов.
  //* Класс нельзя объявить внутри функций.
  //* Синтаксис - class ClassName { **Область видимости класса** }
}

/// Пустой класс
class EmptyClass {}

void createClassObject() {
  //? Создание экземпляра класса
  //* После того, как у нас есть класс, мы можем создать объекты этого класса – экземпляры.
  //* Синтаксис - ClassName objectName = ClassName(); или
  //* modifier objectName = ClassName(); (modifier - final, const, var)

  final emptyObject = EmptyClass();
  EmptyClass anotherEmptyObject = EmptyClass();
  var yetAnotherEmptyObject = EmptyClass();
  // Сравните с
  final generator = Random();

  //* Все дефолтные поля и методы которые есть у каждого класса
  [
    emptyObject.hashCode,
    emptyObject.runtimeType,
    emptyObject.toString(),
  ].forEach(print);
}

void addMethods() {
  //? Добавление методов в класс
  //* Методы – это функции, объявленные внутри класса. Они могут быть вызваны у объектов этого класса.
  //* Синтаксис - как у обычных функций

  final objectWithMethods = ClassWithMethods();
  objectWithMethods.greeting();
  print(objectWithMethods.calculateSum(5, 10));
}

/// Класс с методами
class ClassWithMethods {
  void greeting() {
    print('Hello, World!');
  }

  int calculateSum(int a, int b) => a + b;
}

void addFields() {
  //? Добавление полей в класс
  //* Поля – это переменные, объявленные внутри класса. Они хранят данные объектов.
  //* Синтаксис - как у обычных переменных
  //* НО, сначала модификатор а потом тип (пользоваться var не рекомендуется)

  final objectWithFields = ClassWithFields();

  print('age: ${objectWithFields.age}, name: ${objectWithFields.name}');

  objectWithFields.name = 'Paul';
  objectWithFields.age = 20;
  //! objectWithFields.pi = 3.16; //! Ошибка pi - final

  print('age: ${objectWithFields.age}, name: ${objectWithFields.name}');
}

class ClassWithFields {
  String name = 'Ivan';
  int age = 19;
  final double pi = 3.14;
}

void combinedClass() {
  //? Комбинированный класс
  //* Класс может содержать и методы, и поля
  //* Синтаксис - объявляем поля, методы внутри класса

  final combinedObject = CombinedClass();
  combinedObject.greeting();
  combinedObject.name = 'Marcus';
  combinedObject.greeting();
}

class CombinedClass {
  String name = 'Ivan';

  void greeting() => print('Hello $name');
}

void constructors() {
  //* Пока что мы создавали объекты с помощью конструктора по умолчанию
  //* И всем полям мы присваивали значения зарананее
  //* Но что если мы хотим создать объект с разными данными? - Используем конструкторы

  //? Инкапусуляция уже произошла?
  //* Только лишь от части:
  //* Мы объеденили поля и методы лишь в классе CombinedClass, но мы не скрыли детали реализации
  //* Тем более наш CombinedClass управляется извне (изменением поля name), а не самостоятельно
  //* Так что до инкапсуляции еще далеко

  //? Конструкторы
  //* Конструктор – это специальный метод, который вызывается при создании объекта.
  //* У конструктора 4 части: имя, список параметров, список иницилизации и тело.
  //* В Dart конструкторы могут быть именованными и безымянными (есть еще и другие).

  //? Части подробнее
  //* 1 - Имя конструктора - его может и не быть, но если есть, то это именованный конструктор
  //* 2 - Список параметров - это аргументы, которые передаются в конструктор (может быть преобразован в иницилизацию полей)
  //* 3 - Список иницилизации - это место, где мы можем иницилизировать поля класса
  //* 4 - Тело конструктора - это место, где мы можем выполнять какие-то действия при создании объекта

  //? Синтаксис - здесь очень большое разнообразие, пойдем от начального до продвинутого
  //* Class()
  //* Class() : initList;
  //* Class() { body }
  //* Class() : initList { body }
  //
  //* Class(args...) : initList;
  //* Class(args...) { body }
  //* Class(args...) : initList { body }
  //
  //* Class.named()
  //...
  //* Class.named(args...)
  //...

  final p1 = Point(2, 3);
  final p2 = Point.zero();

  final object1 = ClassWithConstructor('Ivan', 19);
  final object2 = ClassWithConstructor.short('Paul', 20);
  final object3 = ClassWithConstructor.fullDataNamed(name: 'Marcus', age: 21);
  //! object1.name = 'Ivanov'; //! Ошибка name - final
  print(object1.name);

  //? Деструкторы
  //* Деструкторы в Dart отсутствуют, так как у нас присутсвует сборщик мусора
}

class Point {
  final int x;
  final int y;

  Point(int x, int y) : x = x, y = y;

  Point.zero() : x = 0, y = 0;
}

class DiceRoll {
  DiceRoll({required this.edges, required this.count})
    : maxPoints = edges * count;

  final int edges;
  final int count;
  final int maxPoints;
}

class ClassWithConstructor {
  // ClassWithConstructor(); // Это то что генерируется всегда, но мы можем это изменить

  final String name;
  final int age;

  //* Теперь дефолтный конструктор принимает два параметра
  //* И теперь нельзя создать объект просто через ClassWithConstructor();
  //!!! Поля класса должны быть обязательно иницилизированы ДО тела конструктора
  ClassWithConstructor(String name, int age) : name = name, age = age;

  ClassWithConstructor.fullData(String name, int age) : name = name, age = age;

  //* this - это ссылка на текущий объект (решение проблемы с пересекающимся lexical scope)
  ClassWithConstructor.fullDataWithThis(String name, int age)
    : this.name = name,
      this.age = age;

  ClassWithConstructor.fullDataNamed({required String name, required int age})
    : name = name,
      age = age;

  ClassWithConstructor.fullDataNamedWithDefault({
    String name = 'Ivan',
    int age = 19,
  }) : name = name,
       age = age;

  ClassWithConstructor.fullDataNamedWithDefaultAndBody({
    String name = 'Ivan',
    int age = 19,
  }) : name = name,
       age = age {
    print('Object created with name: $name and age: $age');
  }

  ClassWithConstructor.zeroData() : name = 'Ivan', age = 19;

  ClassWithConstructor.fullDataWithAnotherVariableNames({
    String surname = 'Ivanov',
  }) : name = surname,
       age = surname.length;

  //* Сокращенные конструкторы (рекомендованные к использованию)
  ClassWithConstructor.short(this.name, this.age);

  ClassWithConstructor.namedShort({required this.name, required this.age});

  ClassWithConstructor.combined(String someName, {required this.age})
    : name = someName;
}

void halfOfEncapsulation() {
  //* Теперь когда мы знаем что такое конструкторы, мы можем реализовать инкапсуляцию (на половину)
  //* Создадим класс монстра

  final human = Monster.human(health: 100, damage: 10);
  final goblin = Monster.goblin();
  final shrek = Monster(name: 'Shrek', health: 200, damage: 50);

  human.showInfo();
  goblin.showInfo();
  shrek.showInfo();

  shrek.attack(human);
  human.showInfo();
}

class Monster {
  Monster({required this.name, required int health, required this.damage})
    : _health = health;

  Monster.human({required int health, required this.damage})
    : _health = health,
      name = 'Human';

  //* Вызов конструктора из конструктора
  //Monster.goblin() : this(name: 'Goblin', health: 120, damage: 5);
  Monster.goblin() : name = 'Goblin', _health = 120, damage = 5;

  Monster.orc() : this(name: 'Orc', health: 200, damage: 10);

  Monster.godHuman() : this.human(health: 999999, damage: 999999);
  Monster.mutation(String name)
    : this(name: name, health: 999999, damage: 999999);

  final String name;
  int _health;
  final int damage;

  void attack(Monster enemy) {
    enemy._health -= damage;
  }

  void showInfo() {
    print('Name: $name, Health: $_health, Damage: $damage');
  }
}

void fullEncapsulation() {
  //* Теперь мы можем реализовать полную инкапсуляцию
  //* Нам нужно реализовать вторую заповедь инкасуляции - скрыть детали реализации

  //? Модификаторы доступа
  //* 1. public - доступен из любого места программы
  //* 2. private - доступен только внутри класса
  //* 3. protected - доступен внутри класса и его наследников

  //; В dart нету protected

  //* Все поля класса и методы по дефолту public
  //* Для того чтобы сделать поле или метод private, нужно поставить перед именем поля/функции _
}

void commandmentsOfOOP() {
  //* ООП позволяет сделать вообще всё, но в этом кроется и некоторая проблема
  //* Как имея такие возможности не написать плохого кода?
  //* Для этого существуют правила написания хорошего кода
  //* Их очень и очень много
  //* Но есть основное - акроним S.O.L.I.D

  //? Благодаря Dart и его строгой типизации принцип L автоматически выполняется (его невозможно нарушить)
  //* Остается SOID
  //* Изученная нами инкапсуляция поможет нам понять и применить принцип S
  //* S - Single Responsibility Principle (Принцип единственной ответственности)

  //? Хоть инкапсуляция и предоставляет лишь возможность скрыть детали реализации, это нужно делать всегда!
  //* Если мы будем изменять состояние объекта извне, то это будет нарушением инкасуляции

  //? Пытаемся следовать следующим пунктам
  //* 1. Делаем все private, что можно
  //* 2. Изменяемые поля ТОЧНО ВСЕГДА private
  //* 3. Для доступа к полям можно использовать методы (самописные)
}

void retell() {
  //* Повторим и поразмышляем об изученном

  //* Инкапсуляция позволяет нам начать мыслить объектно-ориентированно, так как мы начинаем выделять сущности и их обязанности
  //* Мы создаем классы, которые содержат в себе поля и методы, характерные для объектов этого класса
  //* Мы также имеем возможность менять содержимое полей от объекта к объекту с помощью конструкторов
  //* Ведь два человека могут иметь разные имена и возрасты, но они оба являются объектами класса Human

  //* Второй принцип инкапсуляции - скрытие детали реализации, помогает нам сделать объект более самостоятельным и надежным.

  //* На данный момент мы достаточно раскрыли эту тему
  //* Но остались еще не изученные моменты:
  //* сеттеры, геттеры, фабричные конструкторы, статические методы и поля, ленивые и поздноинициализированные поля и т.д.
}

void main() {
  final labels = {
    'introduction': introduction,
    'terms': terms,
    'encapsulation': encapsulation,
    'createClass': createClass,
    'createClassObject': createClassObject,
    'addMethods': addMethods,
    'addFields': addFields,
    'combinedClass': combinedClass,
    'constructors': constructors,
    'halfOfEncapsulation': halfOfEncapsulation,
    'fullEncapsulation': fullEncapsulation,
    'commandmentsOfOOP': commandmentsOfOOP,
    'retell': retell,
  };

  for (final MapEntry(key: title, value: action) in labels.entries) {
    print('${'=' * 20} $title ${'=' * 20}');
    action();
    print('\n');
  }
}

// Тренировка: Выделения сущностей и их обязаностей
//? Из реального мира:
//* 1. Кафе
//* 2. Интернет-магазин
//* 3. Больница
//* 4. Спортивный клуб
//? Из прикладного уровня:
//* 1. Wordle (Input, AttempPresentation, RoundResult, Round)
//* 2. Мобильное приложение (Widget, Screen, Buttons, User, Settings, Store, Navigator)
//* 3.

// Задание: проектирование классов + проверка синтаксиса

//* 1. Класс "BankAccount"
//* Создайте класс BankAccount, который будет представлять банковский счет. Инкапсулируйте данные о балансе счета.
//* Создайте желаемое кол-во конструкторов.
//* Реализуйте публичные методы для:
//* - Получения текущего баланса.
//* - Внесения денег на счет.
//* - Снятия денег со счета.

//* 2. Класс "Student"
//* Создайте класс Student, который будет представлять студента. Инкапсулируйте данные о его оценках и других данных (придумайте еще 2-3 поля).
//* Создайте желаемое кол-во конструкторов
//* Реализуйте публичные методы для:
//* - Добавления новой оценки.
//* - Получения средней оценки.
//* - Получение форматированной информации о студенте и его оценках.

//* 3. Класс "LibraryBook"
//* Создайте класс LibraryBook, который будет представлять книгу в библиотеке. Реализуйте инкапсуляцию данных, конструкторы, приватные методы и поля.
//* Нужны поля для хранения названия книги, автора и статуса доступности (сами определите уровень доступности)
//* Реализуйте публичные методы для:
//* - Получения информации о книге (название и автор).
//* - Проверки доступности книги.
//* - Взятия книги (если она доступна).
//* - Возвращения книги.
//* Используйте приватный метод для обновления статуса доступности книги.
