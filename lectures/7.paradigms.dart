// ignore_for_file: unnecessary_statements, cascade_invocations, unused_import

import 'dart:io';
import 'dart:math';

import 'package:coca_code/hello.dart';

void paradigms() {
  //? Парадигмы
  //* Парадигма разработки – это набор правил и критериев, соблюдаемых разработчиками,
  //* чтобы выдержать конкретную стилистику и модель написания кода.

  //* Единая парадигма помогает избегать ошибок, упрощает работу в команде и ускоряет разработку.
  //* Ориентируясь на одну парадигму, можно корректно структурировать код приложения,
  //* зная четкие правила, выбранные командой, которая работает над конкретным проектом.

  //* Существуют различные типы парадигм, например процедурный, ориентированный на работу с функциями,
  //* или логический, подразумевающий решение базовых логических задач в духе «если А = true, то и B = true».
  //* Но есть и более интересный подход к решению задач разработки, и это ООП-парадигма.

  //? Процедурное программирование
  //* 1. Состояние и изменяемость: Процедурное программирование работает с изменяемыми состояниями и переменными.
  //* 2. Контроль потока: Использует конструкции управления потоком, такие как циклы (for, while) и условные операторы (if, switch).
  //* 3. Функции и процедуры: Функции и процедуры изменяют состояния и переменные, часто используя побочные эффекты.
  //; Процедура - функция не возращающая значения
  //; Побочные эффекты - изменение состояния вне функции (Изменение глобальных переменных, изменение аргументов ссылок и т.д.)

  //? Функциональное программирование
  //* 1. Неизменяемость (иммутабельность): Данные неизменяемы; функции не изменяют их, а создают новые.
  //* 2. Чистые функции: Функции, которые не имеют побочных эффектов и всегда возвращают один и тот же результат для одного и того же набора входных данных.
  //* 3. Функции высшего порядка: Функции, которые принимают другие функции в качестве аргументов или возвращают их.
  //* 4. Отсутствие состояния: Нет глобального состояния; управление осуществляется через передачу данных между функциями.
  //; Чистая функция - функция, которая не имеет побочных эффектов
  //; Функция высшего (первого) порядка (класса) - функция, которая может быть передана в качестве аргумента другой функции

  //? Правила написания хорошего кода (основываясь на простой логике)
  //; Принципы ХАБУБА
  //* 1. Хорошее именование
  //* 2. Атомарные функции
  //* 3. Без повторений
  //* 4. Упрощение кода
  //* 5. Без хардкода (магические данные)
  //* 6. Активный рефакторинг
}

void ownProject() {
  //* Вам предстоит создать собственный консольный проект на Dart для укрепления навыков
  //* В последствии на основе вашего проекта мы будем разбирать ООП

  //? Тема проекта - "Вордли"
  //? Требования:
  //* 1. Программа должна быть консольной
  //* 2. Программа должна быть написана на Dart
  //* 3. Программа должна быть написана по принципам "Хабуба"
  //* 4. Программа должна быть реализована с помощью Процедурной и (или) Функциональной парадигмы
  //? Функциональные требования
  //* 1. Программа должна загадывать случайное слово из предустановленного списка слов.
  //* 2. Пользователь должен иметь ограниченное количество попыток для угадывания слова (стандартно 6 попыток).
  //* 3. После каждой попытки программа должна выводить подсказку (можно поменять):
  //*  - Заглавные буквы для правильно угаданных букв, стоящих на своих местах.
  //*  - Строчные буквы для правильно угаданных букв, не на своих местах.
  //*  - Дефисы для букв, которых нет в загаданном слове.
  //* 4. После каждой попытки программа должна выводить текущее состояние слова.
  //* 5. После завершения игры программа должна предложить пользователю возможность начать новую игру или выйти.
  //* 6. Программа должна предлагать возможность воспользовать подсказкой (придумайте 2 типа подсказок)
  //* 7. Программа должна ввести счёт очков, побед и поражений
  //* 8. Должна быть возможность вывести статистику игр
  //! 9. Программа должна быть стабильной и не вылетать при некорректных действиях пользователя
}

void consoleArgs() {
  //* Консольные аргументы - это аргументы, которые передаются программе при её запуске через консоль
  //* Пример: dart main.dart arg1 arg2 arg3
  //* В Dart консольные аргументы можно получить через args в main
  //* Пример:
  //; void main(List<String> args) {
  //;   print(args);
  //; }
}

void environment() {
  //* Переменные окружения - это переменные, которые хранятся в системе и доступны для всех программ
  //* Пример: PATH, HOME, USERPROFILE
  //* В Dart переменные окружения можно получить через Platform.environment
  //* Или через String.fromEnvironment
  //* Пример:
  //; void main() {
  //;   print(Platform.environment);
  //;   print(String.fromEnvironment('PATH'));
  //; }
  //* Также переменные окружения можно установить при запуске или при компиляции
  /*
  * $ dart run --define=DEBUG=true -DFLAVOR=free main.dart
  * $ dart compile exe --define=DEBUG=true -DFLAVOR=free main.dart
  * $ dart compile js --define=DEBUG=true -DFLAVOR=free main.dart
  * $ dart compile aot-snapshot --define=DEBUG=true -DFLAVOR=free main.dart
  * $ dart compile jit-snapshot --define=DEBUG=true -DFLAVOR=free main.dart
  * $ dart compile kernel --define=DEBUG=true -DFLAVOR=free main.dart
  */
}

void imports() {
  //* Импорты - это подключение библиотек и файлов к вашему проекту
  //* Чтобы импортировать свой файл, используйте import 'package:project_name/file_name.dart';
  //* При этом импортируемый файл должен находиться в папке lib вашего проекта!

  // Пример:
  // import 'package:coca_code/hello.dart';
  // hello(); // Вызовется функция hello из файла hello.dart
}

void timers() {
  //* Как считать время выполнения программы?
  //* Для этого можно использовать Stopwatch
  //* Пример:
  final stopwatch = Stopwatch()..start();

  // Ваш код
  Iterable<int>.generate(1000000).where(isPrime).toList();

  stopwatch.stop();

  print('Execution time: ${stopwatch.elapsed.inMilliseconds}');
}

void files() {
  //* Работа с файлами
  //* Для работы с файлами в Dart используется библиотека dart:io
  //* Пример:

  final file = File('file.txt');
  print(file.existsSync());
  print(file.existsSync() ? file.readAsLinesSync() : 'No file');
}

void main(List<String> args) {
  // dart run --define=A=5 -DFLAVOR=A .\lectures\7.paradigms.dart
  print(args);
  print(const String.fromEnvironment('PATH', defaultValue: 'NO PATH'));
  print(const String.fromEnvironment('A'));
  print(const String.fromEnvironment('FLAVOR'));
  timers();
  files();
}
